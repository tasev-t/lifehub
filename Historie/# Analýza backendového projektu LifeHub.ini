# Analýza backendového projektu LifeHub

## Silné stránky

- **Modulární architektura**: Backend je modulárně rozdělen do samostatných Django aplikací (`users`, `nutrition`, `finance`, `pets`, `common`), což zlepšuje čitelnost kódu a umožňuje vývoj a údržbu jednotlivých částí nezávisle. URL jednotlivých modulů jsou správně začleněny do hlavního routeru (např. `path('api/users/', include('users.urls'))` atd.), takže celek funguje jako jednotné API. Tato oddělená struktura odpovídá osvědčeným postupům pro Django projekty a usnadní případné rozšiřování projektu o další oblasti.

- **Využití standardních frameworků a knihoven**: Projekt využívá robustní Django REST Framework a ověřené balíčky pro autentizaci uživatelů (`dj-rest-auth` spolu s `django-allauth` pro registrace a přihlášení, plus SimpleJWT pro správu JWT tokenů). Není tedy potřeba „vynalézat kolo“ pro běžné funkce – použití těchto knihoven zajišťuje standardní, otestovanou a bezpečnou implementaci (např. ověřený průběh registrace, možnost resetu hesla, správa tokenů) a snadnou integraci JWT do frontendu. Konfigurace v `settings.py` (např. nastavení `REST_FRAMEWORK` a `SIMPLE_JWT`) naznačuje, že JWT autentizace je nastavena správně (kombinace SessionAuthentication a JWTAuthentication), takže backend umí pracovat jak s tradičními session cookies, tak s Bearer tokeny dle potřeby.

- **Vlastní model uživatele s rozšířením pro rodinu**: Byl zaveden vlastní model uživatele `UserProfile` děděním z `AbstractUser`, který přidává atributy jako `profile_mode` a vazbu na `FamilyGroup`. Tento přístup umožňuje rozšířit základní informace o uživateli (např. režim osobní vs. rodinný) a připravuje půdu pro sdílení dat mezi více uživateli v rámci rodiny. Návrh s modelem `FamilyGroup` (a vazbou z uživatele na tuto skupinu) je elegantní řešení pro rodinné účty a ukazuje, že systém je již od začátku navržen s ohledem na budoucí funkce spolupráce mezi uživateli.

- **Implementace klíčových funkcí**: Backend již pokrývá základní API endpointy potřebné pro MVP aplikace. Nechybí registrace nového uživatele, přihlášení (vydání JWT tokenu), zobrazení a editace uživatelského profilu, získání seznamu receptů a kompletní CRUD operace pro ingredience a jídelní plány. K dispozici jsou i pomocné systémové endpointy jako changelog (`/api/common/changelog/`) a snapshot struktury kódu (`/api/common/snapshot/`). Uživatel se tak může zaregistrovat, přihlásit a s tokenem provádět chráněné operace – např. načíst svůj profil či přidat ingredienci do seznamu. To dokládá, že jednotlivé části systému (uživatelé, autentizace, modul strava atd.) jsou integrovány a dokáží spolupracovat (například autentizace pomocí JWT je sdílená napříč všemi API endpointy).

- **Čistota a čitelnost kódu**: Kód je napsán přehledně a udržovatelně. Struktura projektových souborů i pojmenování tříd a funkcí jsou logické (např. view třídy odpovídají svému účelu: `RecipeListView`, `MealPlanDetailView` apod.). Využití generických pohledů DRF (`ListAPIView`, `ListCreateAPIView`, atd.) omezuje duplicitní kód a udržuje logiku jednoduchou. Kde je nutná vlastní funkčnost (např. přepínání režimu profilu v metodě `UserProfileView.put`), je implementace srozumitelná a počítá s okrajovými situacemi (kontrola platné hodnoty `profile_mode`, použití `get_or_create` pro vytvoření rodinné skupiny atd.). Nechybí komentáře vysvětlující záměr v obtížnějších pasážích kódu, což usnadňuje orientaci novým vývojářům.

- **Základní zabezpečení**: V projektu jsou zavedena důležitá bezpečnostní opatření hned od počátku. Citlivý endpoint `/api/common/snapshot/` (který vypisuje strukturu projektových souborů) je chráněn – vyžaduje administrátorská oprávnění (`permission_classes = [IsAdminUser]`), takže jej nemůže volat nepovolaný uživatel. Hesla uživatelů se ukládají bezpečně: při registraci se využívá metoda `set_password`, která heslo zahashuje (neukládá se tedy v čitelné podobě). Pro autorizaci API volání jsou použity JWT tokeny s omezenou platností access tokenu a možností obnovy přes refresh token, což je moderní a bezpečný přístup minimalizující riziko zneužití dlouhodobých platných tokenů. Díky integraci Django Allauth je navíc k dispozici robustní základ pro správu účtů (ověřování emailů, obnova hesla atd.), což zvyšuje důvěryhodnost řešení autentizace.

- **DevOps a údržba**: Projekt myslí i na údržbu a konzistenci kódu. Součástí repozitáře jsou automatizační skripty (např. `.bat` soubory pro rychlé provedení migrací a spuštění serveru) a nástroj `snapshot_generator.py` pro vygenerování archivního snapshotu celého projektu. To svědčí o dobré praxi – vývojář průběžně zaznamenává stav kódu a může jej snadno sdílet nebo analyzovat změny v čase. Dokumentace projektu (soubor **Komplexní přehled projektu**) poskytuje ucelený kontext, vysvětluje technické detaily a navrhuje další kroky, což je velké plus pro onboardování nových členů týmu. Celkově je tedy kladen důraz na organizovanost a snadnou udržovatelnost projektu od samého začátku.

## Identifikované problémy

- **Chybějící oddělení dat uživatelů**: Momentálně modely v modulu *Strava* (`Recipe`, `Ingredient`, `MealPlan`) nejsou navázány na konkrétního uživatele (chybí např. pole `owner` u záznamů) a endpointy nemají omezení přístupu. Všechny vytvořené položky jsou tedy sdílené globálně pro všechny uživatele. V multi-uživatelském prostředí to představuje problém soukromí i logiky – aplikace nerozlišuje, komu data patří. Například kdokoli (i nepřihlášený uživatel) může nyní přidat ingredienci nebo jídelníček a všichni ostatní je uvidí, případně je mohou upravit či smazat. To není žádoucí chování a v budoucnu by vedlo k chaosu v datech.

- **Nekonzistence v API modulu strava**: Zatímco recepty jsou přes API dostupné jen pro čtení (endpoint `/api/nutrition/recipes/` poskytuje list receptů, ale neumožňuje jejich vytvoření či editaci přes API), ingredience a jídelníčky mají aktuálně plný CRUD přístup bez omezení. Tato nelogická nekonzistence může způsobit potíže: buď by i recepty měly mít možnost tvorby a úpravy (pokud se počítá s tím, že uživatelé budou přidávat vlastní recepty), nebo naopak vytváření ingrediencí a jídelních plánů by mělo být obdobně omezeno (pokud mají být tyto entity centrálně spravovány nebo jen pro přihlášené uživatele). Nynější stav umožňuje neřízené přidávání záznamů všemi uživateli a míchá dohromady data všech, což z hlediska konzistence a pravomocí není ideální.

- **Nastavení JWT – rotace tokenů a blacklist**: Aplikace využívá JWT autentizaci a v nastavení je zapnuta rotace refresh tokenů (`ROTATE_REFRESH_TOKENS = True`) a jejich zneplatňování po použití (`BLACKLIST_AFTER_ROTATION = True`). Nicméně, chybí implementace mechanismu blacklist – konkrétně není v `INSTALLED_APPS` přidána aplikace SimpleJWT blacklistu (`rest_framework_simplejwt.token_blacklist`). V důsledku toho se staré refresh tokeny po rotaci pravděpodobně vůbec neukládají do žádné blacklist tabulky a mohou zůstat platné až do své expirace. To oslabuje zamýšlené zabezpečení rotace tokenů (útočník by mohl potenciálně použit starý refresh token, pokud by jej získal). Navíc není zatím řešen explicitní **logout** pro JWT – po odhlášení uživatele na klientovi zůstává refresh token na straně serveru platný (pokud není blacklistován). Bez blacklistu nebo jiného mechanismu server nepozná, že se uživatel odhlásil, a token může být zneužit, dokud nevyprší.

- **Příliš otevřená CORS politika**: V nastavení je uvedeno `CORS_ALLOW_ALL_ORIGINS = True`, což sice během vývoje usnadňuje testování (API přijímá požadavky odkudkoli), ale v produkčním nasazení jde o bezpečnostní riziko. Takto nastavené CORS umožní libovolné doméně odesílat požadavky na backend. Pokud by například aplikace používala autentizaci přes cookie nebo by prohlížeč uchovával JWT token a posílal ho automaticky (s `withCredentials`), mohla by škodlivá stránka z jiné domény využít otevřeného CORS a přistupovat k API jménem přihlášeného uživatele. I když aktuálně JWT asi nebude automaticky posílán prohlížečem (pokud je uložen např. v localStorage), ponechání CORS otevřeného není podle best practices vhodné – mělo by se omezit na důvěryhodné frontendové domény.

- **Tvrdě zakódovaný tajný klíč a debug režim**: V souboru nastavení je `SECRET_KEY` napevno uveden jako výchozí insecure klíč (`"django-insecure-CHANGE_ME"`). To představuje riziko, pokud by se kód dostal do nepovolaných rukou nebo byl nasazen bez změny klíče – útočník by mohl tokeny podepisované tímto klíčem snadno falšovat nebo dešifrovat data zabezpečená tímto tajemstvím. Stejně tak `DEBUG = True` je ponecháno zapnuté. V produkčním prostředí by to mohlo vést k úniku citlivých informací (např. tracebacky chyb) a obecně to není bezpečné. Aktuálně to nevadí, protože jde zřejmě o vývojové nastavení, ale je potřeba na to pamatovat před nasazením.

- **Nedostatky v konfiguraci autentizace (allauth)**: Projekt naznačuje, že chce používat email jako hlavní údaj pro login (v nastavení je pokus o `ACCOUNT_LOGIN_METHODS = ['email']` a `ACCOUNT_UNIQUE_EMAIL = True`). Nicméně django-allauth očekává nastavení jako `ACCOUNT_AUTHENTICATION_METHOD = 'email'` a také případně `ACCOUNT_USERNAME_REQUIRED = False`, pokud nemá být vyžadováno uživatelské jméno. V současnosti model `UserProfile` stále obsahuje uživatelské jméno (děděné z AbstractUser) a allauth pravděpodobně povoluje přihlášení jak jménem, tak e-mailem. To nemusí být vysloveně chyba, ale konfigurace není úplně sladěná s cílem autentizovat čistě přes email. Dále existují dvě různé cesty registrace uživatele: jednak přes dj-rest-auth (`/api/auth/registration/` – ta využívá `CustomRegisterSerializer` a vyžaduje zadání `password1` a `password2` pro potvrzení hesla), a paralelně vlastní endpoint `/api/users/register/` s jednodušším serializerem (zde se heslo zadává jen jednou a neprobíhá ověření emailu). Tato duplikace může vést k neočekávanému chování – např. vlastní endpoint dovolí registrovat účet s heslem bez potvrzení nebo s potenciálně duplicitním e-mailem, zatímco dj-rest-auth by to nedovolil. To znamená nejednotnou validaci a tok registrace v systému.

- **Chybějící omezení přístupu (permissions)**: Kromě výše zmíněných endpointů (`users/profile` chráněný přes `IsAuthenticated` a `common/snapshot` chráněný pro admina) nejsou u ostatních view nastaveny specifické `permission_classes`. To znamená, že výchozí nastavení DRF (AllowAny) umožňuje přístup k těmto endpointům komukoli. Například *každý* (i nepřihlášený) může volat `/api/nutrition/ingredients/` nebo `/api/nutrition/mealplans/` a provádět tam změny. Chybí granularity oprávnění – např. neexistuje omezení, že editovat či mazat záznam může jen ten, kdo ho vytvořil, nebo jen administrátor. V současnosti by jeden uživatel mohl teoreticky upravovat či mazat záznamy vytvořené jiným uživatelem, protože aplikace to nijak nekontroluje (data nemají navázaného vlastníka a není nastaven permission na úrovni objektu).

- **Databázový model a vztahy**: Některé vztahy a atributy v datech nejsou dořešené a mohou časem působit potíže:  
  - V modelu `Ingredient` chybí vazba na `Recipe`. Není tak možné přímo určit, které ingredience patří k jakému receptu a v jakém množství (což je pro funkci receptů klíčové). Aktuálně neexistuje nic jako "seznam ingrediencí v receptu".  
  - Model `MealPlan` nemá navázaného vlastníka (uživatele ani rodinu). Pokud má každý uživatel mít své vlastní jídelníčky, mělo by zde být pole, které určuje, komu plán patří (uživatel nebo třeba `FamilyGroup` pro sdílený rodinný plán). Zatím je jídelníček jen obecný a není zřejmé, zda je sdílený či patří jednomu uživateli.  
  - Objekt `FamilyGroup` se sice vytváří automaticky při přepnutí uživatele do rodinného režimu, ale není implementována žádná logika pro přidávání dalších uživatelů do existující skupiny. Například chybí možnost pozvat jiného uživatele do své rodiny nebo registrovat víc uživatelů do jedné skupiny. Rodinný režim tak prozatím funguje jen pro jednoho uživatele a jeho vlastní (nově vytvořenou) skupinu, kterou nikdo jiný nesdílí.  
  - U některých polí by mohlo dojít ke kolizím a nekonzistenci – například `Ingredient.name` není unikátní, takže lze vložit duplicitní názvy ingrediencí. Podobně `Recipe.title` může být u více receptů stejný. To samo o sobě nemusí být chybou, ale v kombinaci s neoddělením podle uživatele/rodiny by v systému mohlo být více položek se stejným názvem patřících různým lidem, což znesnadní orientaci. Bez dodatečných omezení nebo struktury (např. kategorizace ingrediencí, nebo vlastník receptu) může dojít k nejasnostem v datech.

- **Nedokončené moduly**: Dvě aplikace v projektu, `finance` a `pets`, jsou zatím jen ve formě kostry (skeletonu). Mají založené soubory a v `urls.py` prázdné patterny, případně jednoduché placeholder view, ale žádnou skutečnou funkcionalitu. To samo o sobě nebrání chodu projektu (nic na ně není navázáno), ale je dobré to zmínit: aktuálně tyto části neposkytují žádné API a jakýkoli pokus je využít (např. volat `/api/finance/...`) by skončil 404 nebo prázdnou odpovědí. Je to očekávané vzhledem k rozpracovanosti projektu, jen je třeba pamatovat na jejich doplnění v dalších fázích vývoje.

- **Testování a drobné nedostatky v kódu**: Kromě jednoho API testu registrace (`users/tests.py` obsahuje jednoduchý test úspěšné registrace přes dj-rest-auth) chybí unit testy pro většinu klíčových funkcí. To znamená, že případné chyby nebo regresy při změnách kódu nemusí být hned odhaleny. Kvalita kódu je jinak na dobré úrovni – dodržuje konvence frameworku, kód je logicky organizován – jen menší detaily by šlo vylepšit. Například některé komentáře v kódu jsou ponechány v češtině (což není problém pro místní tým, ale angličtina je běžnější pro komentáře v open-source projektech) a občas se v nastavení objevují ne zcela přesné názvy konfigurací (viz zmíněné nastavení allauth). Tyto drobnosti však zásadně neovlivňují běh aplikace, jde spíše o konzistenci a profesní styl.

- **Výkon a škálovatelnost**: Použití SQLite databáze v developmentu je v pořádku pro testování, ale pro produkční nasazení a větší počet uživatelů/objem dat by bylo nevyhovující. Projekt s tím počítá – v dokumentaci je doporučeno přejít na PostgreSQL – ale aktuálně by např. souběžné zápisy mohly dělat problém, nebo by nastaly limity SQLite při velkých tabulkách. Také chybí stránkování (pagination) u výpisů – např. endpoint vracející všechny recepty posílá kompletní seznam najednou. S malým množstvím dat to nevadí, ale pokud by databáze obsahovala stovky či tisíce záznamů, může dojít ke zhoršení výkonu a dlouhým odezvám. Škálovatelnost tedy zatím nebyla řešena, což je pochopitelné v rané fázi, ale bude to důležité pro budoucí vývoj.

## Doporučená vylepšení

- **Oddělení uživatelských dat a nastavení oprávnění**: Zaveďte vazbu mezi daty a uživatelem (případně rodinou). Konkrétně přidejte pole typu ForeignKey na uživatele (`owner`) u modelů, které mají být uživatelsky specifické – např. u `MealPlan` a potenciálně i u `Recipe` (pokud uživatelé budou mít vlastní recepty) či `Ingredient` (pokud bude seznam ingrediencí udržován per uživatel nebo per rodina). Podle zvolené logiky pak upravte view tak, aby filtrovaly data podle přihlášeného uživatele nebo jeho `family_group`. Můžete také vytvořit vlastní permission třídu (např. `IsOwner`), která ve `has_object_permission` ověří, že daný objekt patří aktuálně autentizovanému uživateli. Tím zajistíte, že uživatel uvidí a upraví jen své (případně své rodiny) záznamy. Globální sdílení dat ponechte jen tam, kde je to záměr (např. veřejná databáze receptů spravovaná adminem).

- **Rozšíření modelů a vztahů v modulu Strava**: Propojte entity *Recept* a *Ingredience*, abyste mohli evidovat složení receptů. Doporučené řešení je zavést mezitabulku (model) například `RecipeIngredient`, který bude obsahovat cizí klíč na `Recipe`, cizí klíč na `Ingredient` a pole pro množství. Model `Recipe` pak může mít pole `ingredients = ManyToManyField(Ingredient, through=RecipeIngredient, ...)`. Tím budete moci k receptu přiřadit konkrétní ingredience s uvedením množství (např. 200g mouky apod.). Dále rozhodněte, zda ingredience budou globální pro všechny uživatele (sdílený katalog ingrediencí), nebo zda každý uživatel/rodina má svůj seznam ingrediencí. Podle toho případně přidejte vazbu `owner` i u `Ingredient`, anebo naopak zamezte běžným uživatelům přidávat nové ingredience, pokud to má dělat jen administrátor. Podobně u `MealPlan` zvažte, zda má být navázán na jednotlivce či rodinu a upravte model dle toho (např. pole `family_group = ForeignKey(FamilyGroup, ...)` pokud jídelníček sdílí rodina). Celkově je třeba upřesnit datový model tak, aby reflektoval, jak mají uživatelé data používat (osobní vs. sdílené položky).

- **Úprava přístupu k API a konzistence endpointů**: Nastavte vhodné `permission_classes` u všech view podle povahy dat. Například u všech **nutričních** API (`RecipeListView`, `IngredientListCreateView`, `MealPlanListCreateView` atd.) by mělo platit minimálně, že jen přihlášení uživatelé mohou vytvářet či měnit data (`IsAuthenticated`). Dále, pokud zavedete vazbu na uživatele, upravte querysety tak, aby uživatelé viděli jen své záznamy (např. `queryset = Recipe.objects.filter(owner=request.user)` v rámci view, případně dynamicky ve `get_queryset`). Pro jemnější kontrolu přidejte například vlastní oprávnění na úrovni objektu, aby uživatel nemohl manipulovat s objektem, který mu nepatří, i když ho třeba přes filtraci nevidí.  
  Co se týče samotných endpointů: sjednoťte přístupnost a operace tak, aby dávaly smysl. Jestliže recepty mají být sdílené a jen pro čtení, pak zvažte omezit i vytváření ingrediencí a jídelníčků jen pro administrátora nebo je také označit jako sdílené katalogy. Pokud naopak mají uživatelé spravovat vlastní recepty, přidejte k Recipe endpointu možnost tvorby (změňte `RecipeListView` z read-only `ListAPIView` na `ListCreateAPIView` a případně doplňte `RecipeDetailView` pro editaci/mazání vlastního receptu). Důležité je, aby logika byla konzistentní: buď všechna tato data patří uživateli a ten je spravuje, nebo jsou to jakési "public" zdroje spravované centrálně, ale pak by je běžný uživatel neměl volně měnit. Doporučil bych spíše první variantu (osobní recepty/ingredience/jídelníčky s možností sdílet v rodině).

- **Zabezpečení JWT tokenů**: Pro plnohodnotné využití rotace a blacklistu tokenů doplňte do projektu podporu blacklistu SimpleJWT. Konkrétně přidejte `'rest_framework_simplejwt.token_blacklist'` do `INSTALLED_APPS` a zmigrujte databázi, čímž se vytvoří tabulka pro zneplatněné tokeny. Implementujte endpoint nebo mechanismus pro odhlášení uživatele – např. využijte dj-rest-auth endpoint `/api/auth/logout/` (který lze nastavit i pro JWT), nebo vytvořte vlastní view, ve kterém na straně serveru zneplatníte aktuální refresh token (přidáte jej do blacklistu). Tím docílíte, že po odhlášení uživatele již nebude možné použít starý refresh token k získání nového access tokenu. Zvažte také délku platnosti access tokenu – 5 minut je bezpečné nastavení, ale může být pro uživatele méně pohodlné (časté obnovování). Běžná praxe je nastavovat access token třeba na 15 minut a refresh token na delší dobu (dny), přičemž klientská aplikace si sama hlídá obnovení tokenu na pozadí. Hlavní je mít dobře ošetřenou invalidaci tokenů při jejich rotaci (což vyřeší blacklist) a případně při logout.

- **CORS a produkční nastavení**: Před nasazením do produkce upravte nastavení CORS tak, aby nebylo povoleno vše. Ideálně specifikujte povolené domény frontendu pomocí `CORS_ALLOWED_ORIGINS` (např. URL vašeho hostovaného frontendu) namísto globálního povolení. Zabráníte tím potenciálním útokům z neočekávaných zdrojů. Dále **vypněte DEBUG** a zajistěte, aby se `SECRET_KEY` a další citlivé údaje (např. přihlašovací údaje k databázi) načítaly z prostředí (např. pomocí proměnných prostředí a knihovny typu `python-dotenv`) místo toho, aby byly napevno v kódu. Tím předejdete úniku těchto informací a usnadníte nasazení na různé servery (každý může mít vlastní konfiguraci bez změny kódu). Nezapomeňte také nastavit všechny potřebné hlavičky a parametry pro bezpečný provoz (např. Secure a HttpOnly atributy pro cookies, pokud byste použili cookie pro JWT, a podobně).

- **Konzolidace autentizačních mechanismů**: Zvažte sjednocení registrace a přihlašování do jedné cesty a konfigurace. Doporučený přístup je plně využít `dj-rest-auth` (a tím pádem i django-allauth) pro registraci, login, logout a případně další funkce, protože nabízí jednotný a otestovaný postup. To znamená, že endpoint `/api/auth/registration/` by byl preferovaný pro registraci nových uživatelů. Vlastní endpoint `/api/users/register/` můžete buď odstranit, nebo jej upravit tak, aby interně volal stejné procesy (např. používal stejný serializer) a dodržoval stejná pravidla validace – zejména vyžádání a kontrolu dvojího hesla, kontrolu unikátnosti emailu atd. Sjednocením eliminujete možnost, že by dva různé registrační procesy aplikovaly odlišná pravidla. Dále upravte konfiguraci allauth: chcete-li autentizaci pouze přes email, nastavte v `settings.py` správné klíče (`ACCOUNT_AUTHENTICATION_METHOD = 'email'`, `ACCOUNT_EMAIL_REQUIRED = True`, `ACCOUNT_USERNAME_REQUIRED = False` apod.). Tím zajistíte, že uživatelé nebudou muset zadávat username tam, kde to není potřeba, a že email bude povinný a jedinečný. Výsledkem bude konzistentní zkušenost při přihlašování/registraci a méně prostoru pro neočekávané situace.

- **Dokončení a rozšíření chybějících funkcionalit**: Dopracujte moduly, které jsou zatím jen naznačené, a rozšiřte stávající podle priorit projektu:  
  - **Finance a Pets**: Navrhněte a implementujte základní modely a endpointy pro moduly `finance` a `pets` nebo je prozatím skryjte, pokud nejsou v nejbližším plánu. U **finance** by to mohl být např. model transakce nebo rozpočtu (částka, kategorie, datum, uživatel) a odpovídající CRUD API, aby si uživatel mohl evidovat své výdaje/příjmy. U **pets** zase model pro domácího mazlíčka (jméno, druh, datum narození, případně zdravotní záznamy) a endpointy pro přidání mazlíčka, úpravu, výpis všech mazlíčků uživatele apod. Tím naplníte zamýšlený záběr aplikace a nabídnete uživatelům funkce i v těchto oblastech.  
  - **Vylepšení modulu Strava**: Dokončete plánované části, zejména správu receptů. Umožněte přidávat nové recepty (např. přes autorizovaný POST na `/api/nutrition/recipes/`), editovat a mazat je. Přidejte také případně další atributy k receptu (např. kategorií receptu, seznam tagů, nutriční hodnoty) podle toho, co aplikace potřebuje. V rámci ingrediencí a jídelníčků, po zavedení vazeb na uživatele, zajistěte, že uživatel vždy pracuje jen se svými daty. Můžete také přidat funkce jako kopírování receptu do jídelníčku, generování nákupního seznamu z jídelníčku atd., pokud to spadá do cílů projektu – to však přesahuje čistě backendovou analýzu, jedná se spíše o náměty.  
  - **Rodinné sdílení**: Plně využijte model `FamilyGroup` – implementujte možnost, aby uživatel mohl do své rodiny přidat další členy. Může to být formou pozvánky (uživatel zadá email jiného uživatele, systém mu pošle pozvánku) nebo kódů/QR, případně administrativně. Jakmile budou ve skupině více lidí, bude potřeba upravit logiku některých endpointů: např. rodinný režim může znamenat, že členové rodiny sdílejí své finance, mazlíčky nebo jídelníčky. To by se mělo promítnout do dotazů (např. pokud `user.profile_mode == 'family'`, pak načítat i záznamy patřící `user.family_group`). Zkrátka, dotáhněte funkčnost rodinných skupin tak, aby skutečně umožňovaly spolupráci více uživatelů v rámci jedné domácnosti, což je unikátní funkce projektu.

- **Testování a kvalita kódu**: Doporučuji doplnit sadu testů pro klíčové části aplikace. Využijte Django REST Framework `APITestCase` pro simulaci API volání a otestujte například registraci (již zčásti máte), přihlášení a obnovení tokenu, změnu profilu (přepnutí režimu), a CRUD operace nad recepty/ingrediencemi/jídelníčky v různých scénářích (uživatel může/nemůže upravit cizí záznam apod.). Testy pomohou odhalit chyby při refaktorech a zajistí, že bezpečnostní opatření fungují (např. že nepřihlášený uživatel neprovede nepovolenou akci). Kromě testů zvažte také nastavení CI/CD nástrojů (např. GitHub Actions), které budou automaticky spouštět testy a kontrolovat kvalitu kódu při commitech. Pro samotnou kvalitu kódu můžete nasadit linter (flake8/pylint) a formátovač (black), aby celý tým držel jednotný styl. Díky tomu bude kód konzistentní a připravený na další růst. Dokumentaci udržujte aktuální – změny v API by se měly propsat do README nebo do dokumentu s přehledem projektu, aby všichni členové týmu měli vždy správné informace.

- **Vylepšení architektury do budoucna**: Současná architektura (modulární monolit v Django) je pro počáteční fázi a středně velký projekt naprosto vyhovující. Do budoucna však mějte na paměti možné výzvy s růstem projektu. Pokud výrazně naroste počet uživatelů či množství dat, připravte se na škálování – přechod na PostgreSQL (jak už je plánováno) je první krok. Dále by bylo vhodné zavést stránkování u výpisů větších kolekcí dat (DRF to umožňuje nastavit globálně či per-view), aby se neservírovaly stovky objektů najednou. Pro často čtená data můžete zvážit cachování (např. cachovat výstup endpointu s veřejnými recepty, aby se nemusel generovat při každém požadavku). Pokud by některý modul aplikace začal být velmi komplexní nebo náročný, můžete zvažovat jeho oddělení do samostatné služby/mikroservisy – například pokud by část aplikace vyžadovala výrazně odlišné škálování nebo samostatný tým. Zatím to však není nutné; současný stav dobře využívá síly Django monolitu. Důležité je ale psát kód tak, aby byl modulární a oddělený (což už děláte), což případné pozdější refaktoringy či rozdělení usnadní. S průběžným refaktoringem, optimalizacemi a dodržováním best practices bude architektura připravena na další rozvoj projektu.